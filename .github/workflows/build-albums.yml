name: Build Album Packages

on:
  push:
    paths:
      - "**/*.mp3"
      - "**/*.m4a"
      - "**/README.md"
      - "**/LYRICS.txt"
      - "generate-catalog.py"
      - ".github/workflows/build-albums.yml"
  workflow_dispatch:

jobs:
  build-albums:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install FFmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Convert MP3 to M4A
        run: |
          #!/bin/bash
          set -e

          echo "Checking for MP3 files that need M4A conversion..."
          conversions_made=false

          # Find all MP3 files (more specific pattern)
          while IFS= read -r mp3_file; do
            # Skip if file doesn't exist or is empty
            if [ ! -f "$mp3_file" ] || [ ! -s "$mp3_file" ]; then
              echo "Skipping invalid file: $mp3_file"
              continue
            fi
            
            # Verify it actually ends with .mp3 (case insensitive)
            if [[ ! "$mp3_file" =~ \.(mp3|MP3)$ ]]; then
              echo "Skipping non-MP3 file: $mp3_file"
              continue
            fi
            
            # Get directory and base name without extension
            dir=$(dirname "$mp3_file")
            base=$(basename "$mp3_file" .mp3)
            base=$(basename "$base" .MP3)
            m4a_file="$dir/$base.m4a"

            # Check if M4A already exists
            if [ ! -f "$m4a_file" ]; then
              echo "Converting: $mp3_file -> $m4a_file"
              ffmpeg -nostdin -i "$mp3_file" -vn -map_metadata -1 -metadata artist="Carl Lance" -metadata comment="https://kepello.github.io/Musicplayer/" -c:a aac -b:a 256k -movflags +faststart "$m4a_file" 2>&1 | grep -v "^frame="
              conversions_made=true
            else
              echo "M4A already exists: $m4a_file"
            fi
          done < <(find . -type f \( -name "*.mp3" -o -name "*.MP3" \) ! -path "*/.*")

          if [ "$conversions_made" = true ]; then
            echo "Conversions completed. New M4A files will be committed."
          else
            echo "No conversions needed."
          fi

      - name: Clean metadata on all audio files
        run: |
          #!/bin/bash
          set -e
          
          echo "Cleaning metadata on all audio files..."
          
          # Process all MP3 files
          while IFS= read -r mp3_file; do
            if [ ! -f "$mp3_file" ] || [ ! -s "$mp3_file" ]; then
              continue
            fi
            
            echo "Cleaning metadata: $mp3_file"
            temp_file="${mp3_file}.tmp"
            ffmpeg -nostdin -i "$mp3_file" -vn -map_metadata -1 -metadata artist="Carl Lance" -metadata comment="https://kepello.github.io/Musicplayer/" -c:a copy -f mp3 "$temp_file" 2>&1 | grep -v "^frame=" || true
            
            if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
              mv "$temp_file" "$mp3_file"
            else
              rm -f "$temp_file"
              echo "Failed to clean: $mp3_file"
            fi
          done < <(find . -type f \( -name "*.mp3" -o -name "*.MP3" \) ! -path "*/.*")
          
          # Process all M4A files
          while IFS= read -r m4a_file; do
            if [ ! -f "$m4a_file" ] || [ ! -s "$m4a_file" ]; then
              continue
            fi
            
            echo "Cleaning metadata: $m4a_file"
            temp_file="${m4a_file}.tmp"
            ffmpeg -nostdin -i "$m4a_file" -map_metadata -1 -metadata artist="Carl Lance" -metadata comment="https://kepello.github.io/Musicplayer/" -c:a copy -f ipod -movflags +faststart "$temp_file" 2>&1 | grep -v "^frame=" || true
            
            if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
              mv "$temp_file" "$m4a_file"
            else
              rm -f "$temp_file"
              echo "Failed to clean: $m4a_file"
            fi
          done < <(find . -type f -name "*.m4a" ! -path "*/.*")
          
          echo "Metadata cleaning completed."

      - name: Build track playlists
        run: |
          #!/bin/bash
          set -e

          # Get repo info for URLs
          GITHUB_REPO="${GITHUB_REPOSITORY:-owner/repo}"

          # Function to create single track playlist
          create_track_playlist() {
            local track_path="$1"
            local track_name=$(basename "$track_path")
            
            # Find audio files in track directory (prefer M4A, fallback to MP3)
            m4a_file=$(find "$track_path" -maxdepth 1 -type f -iname "*.m4a" | head -n 1)
            mp3_file=$(find "$track_path" -maxdepth 1 -type f -iname "*.mp3" | head -n 1)
            
            if [ -n "$m4a_file" ] || [ -n "$mp3_file" ]; then
              playlist_file="$track_path/$track_name.m3u8"
              
              echo "#EXTM3U" > "$playlist_file"
              echo "#EXTENC:UTF-8" >> "$playlist_file"
              
              # Add M4A if available
              if [ -n "$m4a_file" ]; then
                m4a_relative_path="${m4a_file#./}"
                m4a_url="https://raw.githubusercontent.com/$GITHUB_REPO/main/$m4a_relative_path"
                echo "#EXTINF:-1,$track_name (AAC)" >> "$playlist_file"
                echo "$m4a_url" >> "$playlist_file"
              fi
              
              # Add MP3 if available
              if [ -n "$mp3_file" ]; then
                mp3_relative_path="${mp3_file#./}"
                mp3_url="https://raw.githubusercontent.com/$GITHUB_REPO/main/$mp3_relative_path"
                echo "#EXTINF:-1,$track_name (MP3)" >> "$playlist_file"
                echo "$mp3_url" >> "$playlist_file"
              fi
              
              echo "Created playlist: $playlist_file"
            fi
          }

          # Find all track directories
          for collection_dir in */; do
            collection=$(basename "$collection_dir")
            
            # Skip special directories
            if [[ "$collection" == "node_modules" ]] || [[ "$collection" == ".git" ]] || [[ "$collection" == ".github" ]]; then
              continue
            fi
            
            # Check for albums
            for album_dir in "$collection_dir"*/; do
              if [ ! -d "$album_dir" ]; then
                continue
              fi
              
              # Process each track directory
              for track_dir in "$album_dir"*/; do
                if [ -d "$track_dir" ]; then
                  if find "$track_dir" -maxdepth 1 -type f \( -iname "*.mp3" -o -iname "*.m4a" \) | grep -q .; then
                    create_track_playlist "$track_dir"
                  fi
                fi
              done
            done
          done

      - name: Build album packages
        run: |
          #!/bin/bash
          set -e

          # Function to create album package
          create_album_package() {
            local collection="$1"
            local album="$2"
            local album_path="$collection/$album"
            
            echo "Processing: $album_path"
            
            # Create temp directories for separate format packages
            temp_dir=$(mktemp -d)
            m4a_album_dir="$temp_dir/${album}-M4A/$album"
            mp3_album_dir="$temp_dir/${album}-MP3/$album"
            mkdir -p "$m4a_album_dir"
            mkdir -p "$mp3_album_dir"
            
            # Find all track directories
            track_num=1
            
            # Create playlists for both formats (for ZIP bundles)
            m4a_playlist="$m4a_album_dir/$album.m3u8"
            mp3_playlist="$mp3_album_dir/$album.m3u8"
            
            echo "#EXTM3U" > "$m4a_playlist"
            echo "#EXTENC:UTF-8" >> "$m4a_playlist"
            
            echo "#EXTM3U" > "$mp3_playlist"
            echo "#EXTENC:UTF-8" >> "$mp3_playlist"
            
            # Create separate standalone playlists with URLs for each format
            standalone_m4a_playlist="$album_path/${album}-M4A.m3u8"
            standalone_mp3_playlist="$album_path/${album}-MP3.m3u8"
            
            echo "#EXTM3U" > "$standalone_m4a_playlist"
            echo "#EXTENC:UTF-8" >> "$standalone_m4a_playlist"
            
            echo "#EXTM3U" > "$standalone_mp3_playlist"
            echo "#EXTENC:UTF-8" >> "$standalone_mp3_playlist"
            
            # Get repo info for URLs
            GITHUB_REPO="${GITHUB_REPOSITORY:-owner/repo}"
            
            # Track if we have files for each format
            has_m4a=false
            has_mp3=false
            
            # Process each track directory in order
            for track_dir in "$album_path"/*/; do
              if [ ! -d "$track_dir" ]; then
                continue
              fi
              
              track_name=$(basename "$track_dir")
              
              # Find audio files in track directory
              m4a_file=$(find "$track_dir" -maxdepth 1 -type f -iname "*.m4a" | head -n 1)
              mp3_file=$(find "$track_dir" -maxdepth 1 -type f -iname "*.mp3" | head -n 1)
              
              if [ -n "$m4a_file" ] || [ -n "$mp3_file" ]; then
                # Pad track number
                padded_num=$(printf "%02d" $track_num)
                
                # Copy M4A if available
                if [ -n "$m4a_file" ]; then
                  output_name="${padded_num} - ${track_name}.m4a"
                  cp "$m4a_file" "$m4a_album_dir/$output_name"
                  has_m4a=true
                  
                  # Add to M4A playlist (relative path)
                  echo "#EXTINF:-1,$track_name" >> "$m4a_playlist"
                  echo "$output_name" >> "$m4a_playlist"
                  
                  # Add to standalone M4A playlist (full URL)
                  m4a_relative_path="${m4a_file#./}"
                  m4a_url="https://raw.githubusercontent.com/$GITHUB_REPO/main/$m4a_relative_path"
                  echo "#EXTINF:-1,$track_name" >> "$standalone_m4a_playlist"
                  echo "$m4a_url" >> "$standalone_m4a_playlist"
                fi
                
                # Copy MP3 if available
                if [ -n "$mp3_file" ]; then
                  output_name="${padded_num} - ${track_name}.mp3"
                  cp "$mp3_file" "$mp3_album_dir/$output_name"
                  has_mp3=true
                  
                  # Add to MP3 playlist (relative path)
                  echo "#EXTINF:-1,$track_name" >> "$mp3_playlist"
                  echo "$output_name" >> "$mp3_playlist"
                  
                  # Add to standalone MP3 playlist (full URL)
                  mp3_relative_path="${mp3_file#./}"
                  mp3_url="https://raw.githubusercontent.com/$GITHUB_REPO/main/$mp3_relative_path"
                  echo "#EXTINF:-1,$track_name" >> "$standalone_mp3_playlist"
                  echo "$mp3_url" >> "$standalone_mp3_playlist"
                fi
                
                track_num=$((track_num + 1))
              fi
            done
            
            # Create separate ZIP files if we found tracks
            if [ $track_num -gt 1 ]; then
              # Create M4A ZIP if we have M4A files
              if [ "$has_m4a" = true ]; then
                output_zip="$album_path/${album}-M4A.zip"
                (cd "$temp_dir/${album}-M4A" && zip -r - "$album") > "$output_zip"
                echo "Created: $output_zip ($(du -h "$output_zip" | cut -f1))"
              fi
              
              # Create MP3 ZIP if we have MP3 files
              if [ "$has_mp3" = true ]; then
                output_zip="$album_path/${album}-MP3.zip"
                (cd "$temp_dir/${album}-MP3" && zip -r - "$album") > "$output_zip"
                echo "Created: $output_zip ($(du -h "$output_zip" | cut -f1))"
              fi
            fi
            
            # Cleanup
            rm -rf "$temp_dir"
          }

          # Find all collections and albums
          for collection_dir in */; do
            collection=$(basename "$collection_dir")
            
            # Skip special directories
            if [[ "$collection" == "node_modules" ]] || [[ "$collection" == ".git" ]] || [[ "$collection" == ".github" ]]; then
              continue
            fi
            
            # Check if this collection has albums (subdirectories with tracks)
            for album_dir in "$collection_dir"*/; do
              if [ ! -d "$album_dir" ]; then
                continue
              fi
              
              album=$(basename "$album_dir")
              
              # Check if album has track directories (containing audio files)
              has_tracks=false
              for potential_track in "$album_dir"*/; do
                if [ -d "$potential_track" ]; then
                  if find "$potential_track" -maxdepth 1 -type f \( -iname "*.mp3" -o -iname "*.m4a" \) | grep -q .; then
                    has_tracks=true
                    break
                  fi
                fi
              done
              
              if [ "$has_tracks" = true ]; then
                create_album_package "$collection" "$album"
              fi
            done
          done

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Generate catalog.json
        run: |
          echo "Generating catalog.json..."
          python generate-catalog.py
          echo "Catalog generation completed!"

      - name: Commit album packages and conversions
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Add files if they exist (using find to avoid pathspec errors)
          find . -name "*.zip" -o -name "*.m3u8" -o -name "*.m4a" | grep -v ".git" | xargs -r git add

          # Add catalog.json if it exists
          [ -f catalog.json ] && git add catalog.json || true

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-generate album packages, catalog, and M4A conversions [skip ci]"
            git push
          fi
